# UDP
---

## UDP 서비스

UDP는 최소의 서비스 모델을 가진 간단한 전송 프로토콜.  

UDP는 비연결형이라 두 프로세스간 통신 전에 핸드쉐이킹을 하지 않음  

UDP는 비신뢰적인 데이터 전송 서비스 제공(UDP는 메시지가 수신 소켓에 도착하는 것을 보장하지 않음)  

UDP는 혼잡제어 방식을 포함하지 않음. 따라서 UDP의 송신 측은 데이터를 원하는 속도로 하위 계층(네트워크 계층)으로 보낼 수 있음.  
이를 통해 일부 손실은 감수할 수 있으나 효율적이기 위해서 최소 전송 속도를 요구하기에   
실시간 애플리케이션 개발자들은 때떄로 애플리케이션이 UDP상에서 수행되는 것을 선택함.   
이로써 TCP의 혼잡제어와 패킷 오버헤드 문제를 회피가능함.   
반면 대부분의 방화벽이 UDP 트래픽을 차단하도록 설정되어 있기 떄문에  
설계자들은 점차적으로 TCP상에서 멀티미디어와 실시간 애플리케이션들이 수행되는 것을 선택하고 있다.  

## 비연결형 트랜스포트: UDP

UDP는 다중화/역다중화 기능과 간단한 오류 검사 기능을 제외하면 IP에 아무것도 추가하지 않음
애플리케이션 개발자가 TCP대신 UDP를 선택한다면, 애플리케이션은 거의 IP와 직접 통신하는 것임.

다중화, 역다중화가 뭐지?
* 하나의 IP로 들어온 패킷을 여러 개의 소켓 중 어느 소켓으로 전달할 것인지? => 역다중화 필요(트랜스포트 계층 세그먼트의 데이터를 올바른 소켓으로 전달하는 작업)  
* 여러 개의 소켓으로부터 들어오는 패킷을 서로 공유하는 네트워크 계층을 통해 전송 -> 다중화 필요()  

UDP는 세그먼트를 송신하기 전에 송신 트랜스포트 계층 개체들과 수신 트랜스포트 계층 개체들 사이에 핸드셰이크를 사용하지 않는다는 점에주의. 이런 이유로 UDP를 비연결형 이라고 한다.  

UDP 소켓: 출발지 포트번호/목적지 포트번호/기타 헤더 필드들/ 애플리케이션 데이터(메시지)

### DNS는 일반적인 UDP를 사용하는 애플리케이션 계층 프로토콜의 예임

호스트에서 DNS 애플리케이션이 질의를 생성할 때, DNS 질의 메시지를 작성하고 UDP에게 메시지를 넘겨줌.  
목적지 종단 시스템 상에서 동작하는 UDP 개체와 함께, 호스트 측 UDP는 어떠한 핸드셰이크도 수행하지 않고 메시지에 헤더 필드를 추가한 후에 최종 세그먼트를 네트워크 계층에 넘겨줌. 
네트워크 계층은 UDP 세그먼트를 데이터그램으로 캡슐화하고 네임 서버에 데이터그램을 송신함. 그때, 질의 호스트에서의 DNS 애플리케이션은 질의에 대한 응답을 기다림.  
만약 질의 호스트가 응답을 수신하지 못하면(아마 하의의 네트워크가 질의나 응답을 분실해서 그럴꺼임.), 질의를 다른 네임 서버에게 송신하거나 요청한 애플리케이션에게 응답을 수신할 수 없다는 것을 통보함  

## UDP의 특징

> 애플리케이션 레벨이 데이터 송신에 대해 정교한 제어를 할 수 있음  
 *  애플리케이션 프로세스가 데이터를 UDP에 전달하면 바로 UDP는 데이터를 UDP 세그먼트로 만들고, 즉시 그 세그먼트를 네트워크 계층으로 전달함,  
 * 애플리케이션은 UDP를 사용할 수 있고, 애플리케이션의 한 부분으로서 UDP의 기본 세그먼트 전달 외에 필요한 어떤 추가 기능을 구현할 수 있음  

> 연결 설정이 없음: (TCP는 데이터 전송 시작전에 3 way handshake를 사용함)UDP는 연결을 설정하기 위한 어떤 지연도 없음. -> 이것이 DNS가 왜 TCP보다는 UDP에서 동작하는지에 대한 일반적인 이유임. (DNS가 만약 TCP에서 동작한다면 많이 느려질 것임.)(하지만 HTTP 문서로 된 웹 페이지는 신뢰성이 중요하기에 UDP보단 TCP를 씀.)  
> 연결 상태가 없음: 연결 상태를 유지하지 않으며 파리미터들중 어떠한 것도 기록하지 않음. 그래서 보통 특정 애플리케이션에 할당된 서버는 애플리케이션이 TCP보다 UDP에서 동작할 때 좀 더 많은 클라이언트를 수용 가능 함.  
 * 작은 패킷 헤더 오버헤드: TCP는 세그먼트마다 20바이트의 헤더 오버헤드를 갖는 반면, UDP는 단지 8바이트의 오버헤드를 가짐.  

> 많은 중요한 애플리케이션은 TCP보단 UDP에서 동작함.   
> UDP는 RIP 라우팅 테이블 갱신에 사용됨.  
> UDP는 네트워크 관리 데이터를 전달하는 데 사용됨. 이런 네트워크 관리 애플리케이션은 네트워크가 혼잡한 상태에 있을 때 자주 동작해야 하므로 이러한 경우에는 UDP가 TCP보다 더 좋음.  
> 또 DNS는 TCP의 연결 설정 지연을 피하기 위해서 UDP에서 동작함.  


애플리케이션 데이터는 UDP 데이터그램의 데이터 필드에 위치함. 예를 들어, DNS에 대한 데이터 필드는 질의 메시지나 응답 메시지 필드에 위치함. 

UDP 헤더는 2바이트씩 구성된 네 개의 필드를 가짐. 포트 번호는 목적지 호스트가 목적지 종단 시스템에서 동작하는(역다중화 기능을 수행하는) 정확한 프로세스에게 애플리케이션 데이터를 넘기게 해줌. 

체크섬은 세그먼트에 오류가 발생했는지를 검사하기 위해 수신 호스트에 의해서 사용됨.

----

# DNS 
---

## DNS - 인터넷 디렉터리 서비스

인터넷 호스트에 대한 식별자중 하나로 host name이 있다.  
* www.naver.com, www.google.com  
* 그러나 호스트 네임은 인터넷에서의 그 호스트 위치에 대한 정보를 거의 제공하지 않음  
* 또 호스트 네임은 길이가 바뀌고 알파뉴메릭 문자로 구성되기에 라우터가 처리하는 데 어려움이 있다.  

이런 이유로 호스트는 주로 IP 주소로 식별된다.
IP 주소는 계층 구조여서 주소를 왼쪽에서 오른쪽으로 조사함으로써 그 호스트가 어디에 위치하는지에 대한 정보를 얻을 수 있다.

## DNS가 제공하는 서비스
> 사람은 좀더 기억하기 쉬운 호스트 네임 식별자를 좋아하지만, 라우터는 고정 길이의 계층구조를 가진 IP 주소를 좋아한다.

> 이런 선호 차이를 절충하기 위해, hostname -> IP address로 변환해주는 디렉터리 서비스가 필요함 -> 이것이 인터넷 DNS(Domain Name System)의 주요 임무임

### DNS는
1. DNS 서버들의 계층구조로 구현된 분산 데이터베이스  
2. 호스트가 분산 데이터베이스로 질의하도록 허락하는 애플리케이션 계층 프로토콜  

DNS는 다른 애플리케이션 프로토콜들이 HTTP, SMTP, FTP 등 사용자가 제공한 호스트 네임을 IP 주소로 변환하기 위해 주로 이용함.

### DNS  수행  예 (사용자의 호스트가 http request 메시지를 웹서버 www.someschool.edu로 보내기 위해 사용자 호스트는 www.someschool.edu의 IP주소를 얻어야만함)
1. 같은 사용자 컴퓨터는 DNS 애플리케이션의 클라이언트 측을 수행함  
2. 브라우저는 URL로부터 호스트 네임 www.someschool.edu를 추출하고 그 호스트 네임을 DNS 애플리케이션의 클라이언트 측에 넘긴다.  
3. DNS 클라이언트는 DNS 서버로 호스트네임을 포함하는 질의를 보낸다.  
4. DNS 클라이언트는 궁극적으로 호스트 네임에 대한 IP 주소를 가진 응답을 받는다.  
5. 브라우저가 DNS로부터 IP주소를 받으면, 브라우저는 그 IP 주소의 80번 포트에 위치하는 HTTP 서버 프로세스로 TCP 연결을 초기화한다.  

이 예로부터 DNS는 DNS를 사용하는 인터넷 애플리케이션에 추가 지연을 준다는 것을 볼 수 있다. 다행히도 원하는 IP 주소는 가까운 DNS 서버에 캐시(cache)되어 있어서 평균 DNS 지연뿐 아니라 DNS 네트워크 트래픽 감소에 도움을 줌

### DNS의 중요한 추가적인 서비스
* __host aliasing__: 복잡한 호스트 네임을 가진 호스트는 하나 이상의 별명을 가질 수 있다. 예를 들어, relay1.west-coast.enterprise.com 같은 호스트 네임은 enterprise.com과 www.enterprise.com 같은 두 개의 별칭을 가질 수 있다. 이경우에 호스트 네임 relay1.west-coast.enterprise.com을 정식 호스트 네임(canonical hostname)이라고 한다. 별칭 호스트 네임은 정식 호스트 네임보다 대체로 기억하기 쉽다. DNS는 호스트의 IP 주소뿐만 아니라 제시한 별칭 호스트 네임보다 대체로 기억하기 쉽다.

* __mail server aliasing__: 전자메일 주소는 기억하기 쉬운것이 좋다. 그런데 메일 서버의 호스트 네임은 좀 복잡하고 기억하기 어려울 수 있다. DNS는 호스트의 IP 주소뿐만 아니라 제공된 별칭 호스트 네임에 대한 정식 호스트 네임을 얻기 위해 메일 애플리케이션에 의해 수행 될 수 있다.

* __load distribution(부하 분산)__: DNS는 중복 웹 서버 같은 여러 중복 서버 사이에 부하를 분산하기 위해서도 사용됨. 인기 있는 사이트들은 여러 서버에 중복되어 있어서, 각 서버가 다른 종단 시스템에서 수행되고 다른 IP주소를 가짐. 중복 웹 서버의 경우, 여러 IP 주소가 하나의 정식 호스트 네임과 연관되어 있다. DNS 데이터베이스는 이 IP 주소 집합을 갖고 있다. 클라이언트가 주소 집합으로 매핑하는 호스트 네임에 대한 DNS 질의를 하면, 서버는 IP 주소 집합 전체를 가지고 응답한다. 그러나 각 응답에서의 주소 순서는 매번 회전한다. 클라이언트는 대체로 주소 집합 내부의 첫 번째 IP 주소로 HTTP 요청 메시지를 보내므로, DNS 회전은 여러 중복 서버들 사이에서 트래픽을 분산하는 효과를 낸다. DNS 회전은 전자메일에서도 사용되어 여러 메일 서버가 동일한 별칭을 가질 수 있다. 최근 아카마이 같은 회사는 웹 콘텐츠 분산을 제공하기 위해 좀더 세련된 방법으로 DNS를 이용하고 있다.
