**과제 1. 해쉬에서 충돌이 무엇이고, 충돌을 어떻게 회피하는지에 대해서 조사하시오.**

- 해시에서 충돌이란?
> 해시에서 충돌이란 해시 함수가 서로 다른 두 개의 입력값에서 동일한 출력값을 내는 것을 의미합니다.

- 충돌을 회피하는 방법
> 충돌은 출력 비트가 입력 비트 보다 짧을 경우 비둘기집 원리에 의해 반드시 발생하기 때문에 충돌 회피에 대한 용어를 정확하게 정의해야한다고 생각합니다. 
>
> 충돌 회피란 충돌이 전혀 발생하지 않는 것이 아니라 충돌이 일어나더라도 key-value 데이터를 안정적이고 효율적으로 저장하고 조회하는 것이라고 정의하겠습니다.
> 
> 또 실제 데이터가 방대할 경우 디스크에 데이터가 저장되며 디스크 I/O는 캐시나 메모리 I/O 보다 인스트럭션 카운트가 천만 배 이상 차이나기 때문에  효율적인 이라는 것의 의미를 디스크 I/O 수가 최소화 되 것이라 정하겠습니다.
>
> 테이블 사이즈가 고정되어 있는 `정적 해싱`에서 충돌을 회피하는 가장 간단한 방법은 충돌이 발생할 때 해당 키에 해당하는 버킷에 오버플로우 체인을 연결하는 것입니다. 버킷 수가 고정 되어 있기 때문에 긴 오버플로우 체인이 형성되어 성능이 저하될 수 있습니다. 그러나 이 방법은 단순하기 때문에 가치있다고 생각합니다. 또 트래픽이 적은 시점에 다시 해싱해서 이상적인 상태로 돌려놓을 수 있습니다.
>
> 위에서 언급한 것처럼 오버플로우 페이지를 추가하지 않기 위해 기존 엔트리들을 이상적인 상태로 새로운 버킷들에 재구성하는 것이 하나의 방법이 될 수 있지만 중대한 결점을 가지고 있습니다. 파일 전체를 읽어야하고 원래 페이지 수의 두 배가 디스크게 기록되어야 하기 때문입니다.
>
> 이 문제는 극복하기 위해 버킷에 대한 포인터의 디렉토리를 사용해서 극복될 수 있습니다. 이 방법은 `확장성 해싱`이라고 부르며 global depth와 local depth 의 변화에 따라 해시 함수가 변화하고 버킷이 분할되거나 병합되어 관리될 수 있습니다. 이 때 해시 함수가 마지막 d개의 비트를 사용하는데 이렇게 함으로서 단순히 디렉토리를 복사함으로써 버킷의 수를 두배로 늘릴 수 있기 때문입니다. 만약 디렉토리가 메모리에 적재될 수 있다면 한 번의 디스크 접근으로 셀렉션을 해결할 수 있지만 그렇지않다면 두 번의 디스크 접근이 필요합니다.
>
> 그 다음 방법으로 `선형 해싱`이라고 불리는 방법이 있습니다. 선형해싱은 확장성 해싱과 유사하게 버킷의 수가 동적이지만 확장성 해싱과 다르게 디렉토리를 포함하지 않고 충돌을 더 자연스럽게 다루며 버킷을 분할하는 시기 선택에 있어서 매우 유연합니다. 선형 해싱은 각 함수의 범위가 앞에 것의 두배가 되는 해싱 함수군을 사용합니다. 그러나 확장 해싱과 다르게 H(i)에서 H(i+1)로 의 전환이 해당 버켓의 수를 두배로 만드는 작업과 함께 한 라운드 전반에 걸쳐 점진적으로 일어납니다. 선형 해싱의 근본적인 아이디어는 분할된 버킷을 잘 선택하면 디렉토리가 필요없다는 것입니다. 균등한 분포의 경우 선형 해싱의 구현으로 등호 셀렉션에 대한 평균 비용이 낮아지지만 편중된 분표의 경우 이러한 구현은 빈 버킷을 발생시키게 되고 이러한 버켓들이 적어도 한 페이지를 차지하게 되어 결과적으로 높은 적재율을 가지는 확장성 해싱에 비해 성능이 낮아지게 됩니다. 


**2. HTTP Protocol 에서 request에서 사용하는 USER-AGENT 헤더를 조사하고, 실제 facebook에서 open graph explorer가 사용하는 facebook의 USER-AGENT를 조사하시오. USER-AGENT 값으로 어떤 변화를 줄 수 있을까요?**

- USER-AGENT 헤더는 왜 만들어졌을까?
> 웹 초기에 웹 제작자들이 더 풍부한 컨텐츠를 제공할 수 있도록 브라우저 제작사에서 기능을 추가하고 있었습니다. 이에 따라 다양한 브라우저가 출시되기 시작했고 최신 브라우저는 더 화려한 기능의 HTML을 제공했습니다. 여러 브라우저가 출시되면서 웹제작자들은 제작한 컨텐츠가 다양한 브라우저에 모두 정상적으로 보일 수 있도록 대책이 필요했습니다. 그 중 하나는 가장 낮은 버전의 HTML을 제공하는 것이었고 다른 방법은 브라우저의 버전을 탐지해 서버가 브라우저에 따라 적합한 컨텐츠를 렌더링하는 것이였습니다. 당시에 브라우저에는 스크립트가 가능하지 않았기 때문에 서버에서 브라우저를 탐지해내기 위해 USER-AGENT헤더가 탄생하게 되었습니다. (참고: http://ohgyun.com/292)

- facebook에서 open graph explorer가 사용하는 USER-AGENT
> facebookexternalhit/1.1 (+http://www.facebook.com/externalhit_uatext.php) 또는 facebookexternalhit/1.1 입니다.

- USER-AGENT 값으로 변화를 줄 수 있는 것
> css에서 대표적으로 USER-AGENT에 따른 변화를 주고 있다고 생각합니다. 크롬 브라우저인지 파이어폭스 브라우저인지, 익스플로러 브라우저인지에 따라 해당 브라우저에 맞는 다른 코드를 실행하도록 만들 수 있습니다.
> 
> 또 특정 크롤러가 콘텐츠에 접근할 수 있는지 여부를 화이트리스트에 추가하여 제어할 수 있습니다.